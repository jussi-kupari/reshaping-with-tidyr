---
title: "R4DS-Quickref: Ch7 -- Functional Programming: purrr"
output: html_notebook
---

### Filtering

One of the most straightforward functional programming patterns is filtering. Here, 
you use a high-order filter function. This function takes a predicate function, that is, a 
function that returns a logical value, and then returns all elements where the predicate 
evaluates to TRUE or all elements where the predicate evaluates to 
FALSE.

```{r}
# Keep even numbers only
is_even <- function(x) x %% 2 == 0

1:10 %>% keep(is_even)
```

```{r}
# Keep odd numbers only

1:10 %>% discard(is_even)
```

When you work with predicates, the negate() function can come in handy. It 
changes the truth value of your predicate, such that if your predicate, p, returns TRUE, 
then negate(p) returns FALSE and vice versa.

```{r}
# Keep even
1:10 %>% discard(negate(is_even))
```

```{r}
# Keep odd
1:10 %>% keep(negate(is_even))
```

Since you already have complementary functions in keep() and discard(), you 
would not use negate() for filtering, though.

`compact()` removes NULL elements from a list

```{r}
# List with empty elements
(y <- list(NULL, 1:3, NULL))
```

```{r}
# Remove NULLs
compact(y)
```

If you access attributes on objects, and those are not set, R will give you NULL as a 
result, and for such cases, compact() can be useful.

```{r}
# Define two vectors
x <- y <- 1:3
x
y

```


```{r}
# Name the elements of one vector, but keep the other unnamed
names(y) <- c("one", "two", "three")
names(y)
names(x)
```

```{r}
# Create a list
(z <- list(x = x, y = y))
```

```{r}
# Remove vector with unnamed elements
z %>% compact(names)
```

### Mapping